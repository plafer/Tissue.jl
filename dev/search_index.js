var documenterSearchIndex = {"docs":
[{"location":"api_reference/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api_reference/#Exported-functions","page":"API reference","title":"Exported functions","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"Modules = [Tissue]\nPrivate = false\nOrder   = [:function, :type]","category":"page"},{"location":"api_reference/#Tissue.start-Tuple{Graph}","page":"API reference","title":"Tissue.start","text":"start(graph)\n\nStart all the calculators and begin pulling data out of the source calculator.\n\nAll calculators run in their own task. A call to start(graph) does not block; it returns after spawning all the tasks.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Tissue.stop-Tuple{Graph}","page":"API reference","title":"Tissue.stop","text":"stop(graph)\n\nStop the graph gracefully. \n\nThe graph will stop pulling new data packets out of the source calculator, and all the tasks running calculators will exit after they are done processing the last generated packet.\n\nTissue.wait_until_done(graph) can be called in the main thread to block it until every calculator is fully terminated and closed.\n\nExamples\n\nusing Tissue\nusing MyGraphs: CoolestGraph\n\ngraph = CoolestGraph()\n\nstart(graph)\nsleep(5)\nstop(graph)\nwait_until_done(graph)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Tissue.wait_until_done-Tuple{Graph}","page":"API reference","title":"Tissue.wait_until_done","text":"wait_until_done(graph)\n\nBlock the main thread until the graph is done.\n\nCan only be called after start(graph) was called. This waits for all the calculators to be finished processing the last packet, and calls close(calculator) for each calculator. This can occur either because stop(graph) was called, or the source calculator indicated that it is done generating data by returning nothing.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Tissue.Graph","page":"API reference","title":"Tissue.Graph","text":"The parent type of all graphs.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Exported-macros","page":"API reference","title":"Exported macros","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"Tissue.@graph(graph_name, init_block)","category":"page"},{"location":"api_reference/#Tissue.@graph-Tuple{Any, Any}","page":"API reference","title":"Tissue.@graph","text":"@graph <GraphName> begin ... end\n\nDefine a graph with a topology as specified in the begin ... end block.\n\nThis defines a struct <GraphName> with a constructor that takes no arguments. In the begin ... end block, use @calculator to define a calculator and @bindstreams to bind the input streams of a calculator to the output streams of other calculators. All @calculator declarations must come before any @bindstreams declaration.\n\nExamples\n\nusing Tissue\n\nstruct SourceCalculator end\nTissue.process(c::SourceCalculator) = 42\n\nstruct WorkerCalculator end\nfunction Tissue.process(c::WorkerCalculator, num)\n    out = do_work(in_num)\n    println(out)\nend\n\n@graph NumberGraph begin\n    # 1. Declare calculators.\n    @calculator source  = SourceCalculator()\n    @calculator worker  = WorkerCalculator()\n\n    # 2. Declare the streams which connects the source to the worker\n    @bindstreams worker (num = source)\nend\n\ngraph = NumberGraph()\n\n\n\n\n\n","category":"macro"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"Tissue.@calculator(assign_expr)","category":"page"},{"location":"api_reference/#Tissue.@calculator-Tuple{Any}","page":"API reference","title":"Tissue.@calculator","text":"@calculator calculator_handle = MyCalculator(arg1, arg2)\n\nCreate a calculator node in a graph.\n\nMarks the calculator_handle variable as a new calculator constructed by MyCalculator(arg1, arg2), a user-defined struct. calculator_handle can then be used in a @bindstreams declaration to bind its input streams to the output streams of other calculators in the graph.\n\nThere must be one and only one source calculator in a graph. The source calculator of a graph is the only calculator which has no input streams. It is called the source calculator because it generates the data that will be processed by the rest of the graph.\n\nMust be used in the begin ... end block of @graph, before all @bindstreams.\n\nExamples\n\nusing Tissue\n\nmutable struct MySourceCalculator\n    last::Int64\n    MySourceCalculator() = new(0)\nend\n\nfunction Tissue.process(c::MySourceCalculator)\n    c.last += 1\n\n    c.last\nend\n\nstruct SinkCalculator end\nfunction Tissue.process(c::SinkCalculator, number_stream)\n    println(num)\nend\n\n@graph PrinterGraph begin\n    @calculator source = MySourceCalculator()\n    @calculator sink = SinkCalculator()\n\n    @bindstreams sink (number_stream = source)\nend\n\n\n\n\n\n","category":"macro"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"Tissue.@bindstreams(calculator_handle, binding_exprs)","category":"page"},{"location":"api_reference/#Tissue.@bindstreams-Tuple{Any, Any}","page":"API reference","title":"Tissue.@bindstreams","text":"@bindstreams calculator_handle (stream1 = calc1) (stream2 = calc2) ...\n\nBind the streams of calculator_handle to the output stream of other calculators in the graph.\n\nMultiple Tissue.process(calc) can be implemented for the same calculator type. @bindstreams selects the Tissue.process(calc) method to be used for calculator calculator_handle in this graph based on which named input streams are bound, and binds the output stream of the specified calculators to these input streams.\n\ncalculator_handle, calc1 and calc2 are variables that were assigned to inside a @calculator declaration. stream1 and stream2 are named streams that were defined in a process(c::CalculatorType, stream1, stream2) method definition.\n\nMust be used in the begin ... end block of @graph, after all @calculator declarations.\n\nExamples\n\nusing Tissue\n\nstruct SourceCalculator end\nTissue.process(c::SourceCalculator) = 42\n\nstruct MyCalculator end\n\n# This method will be selected by the `@bindstreams` declaration\nfunction Tissue.process(c::MyCalculator, stream1::Number)\n    println(stream1)\n    stream1\nend\n\n# This method will not be selected\nfunction Tissue.process(c::MyCalculator, stream1::Number, stream2::Number)\n    sum = stream1 + stream2\n    println(sum)\n    sum\nend\n\n# This method will not be selected\nfunction Tissue.process(c::MyCalculator, stream1::Number, stream2::Number, stream3::Number)\n    sum = stream1 + stream2 + stream3\n    println(sum)\n    sum\nend\n\n@graph MyGraph begin\n    @calculator source = SourceCalculator()\n    @calculator mycalc = MyCalculator()\n\n    @bindstreams mycalc (stream1 = source)\nend\n\n\n\n\n\n","category":"macro"},{"location":"api_reference/#Functions-to-be-implemented-by-user","page":"API reference","title":"Functions to be implemented by user","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"Tissue.process(calculator)","category":"page"},{"location":"api_reference/#Tissue.process-Tuple{Any}","page":"API reference","title":"Tissue.process","text":"process(calculator, ...; graph::Graph)\n\nProcess the input streams into an output.\n\nThe first argument must be the associated calculator. Any other argument defines an input stream to the calculator. An input stream will be named with the exact same name as the corresponding argument. At all times, data coming from mutliple input streams into a process() method is guaranteed to be derived from the same datum generated by the source calculator.\n\nOptionally, if you need a reference to the graph object in the process() method, you can add it as a keyword argument named graph and Tissue.jl will supply a reference to the active graph object.\n\nThe value returned from the method is the value sent to the calculator's output stream. Hence, any calculator that binds one of their input streams with @bindstreams to this calculator's output stream will receive the return value of this method as an argument. nothing is treated specially: it means that the calculator will not process the given input. Any downstream calculator that depends on other calculators too will simply drop the value taken from their output stream.\n\nIt is important to remember that each calculator runs in its own task. Therefore, best practices about concurrency must be applied. Notably, the stream arguments of process() could possibly be accessed by multiple threads simultaneously. Therefore, it is highly recommended to make a deepcopy of an argument before mutating it. This will also make your calculator more reusable across graphs.\n\nMultiple process() methods can be defined per calculator, allowing the calculator to be used in different graph topologies.\n\nArguments\n\ncalculator: the associated calculator\n...: the input streams\n\nExamples\n\nusing Base: deepcopy\n\nfunction process(calc::MyCalculator, in_stream; graph)\n    if some_condition\n        stop(graph)\n    end\n\n    in_stream_copy = deepcopy(in_stream)\n\n    mutate(in_stream_copy)\n\n    return in_stream_copy\nend\n\n\n\n\n\n","category":"method"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"Tissue.close(calculator)","category":"page"},{"location":"api_reference/#Tissue.close-Tuple{Any}","page":"API reference","title":"Tissue.close","text":"close(calculator)\n\nPerform cleanup for the calculator. Optional.\n\nYou can define a method for your calculator type to perform any necessary cleanup. Called by wait_until_done(graph) on each calculator to perform cleanup.\n\nExamples\n\nstruct GoofyCalculator \n    resource\n    function GoofyCalculator() \n        resource = acquire_resource()\n        new(resource)\n    end\nend\n\nfunction process(c::GoofyCalculator, some_stream)\n    use_resource(c.resource)\nend\n\nfunction close(c::GoofyCalculator)\n    release_resource(c.resource)\nend\n\n\n\n\n\n","category":"method"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#A-simple-example","page":"Getting Started","title":"A simple example","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We will build a graph with the following topology.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: Example graph)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The corresponding code to build that graph would be:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Tissue\n\nmutable struct SourceCalculator \n    count::Int64\n    SourceCalculator() = new(0)\nend\n\nfunction Tissue.process(c::SourceCalculator)\n    c.count += 1\n    if c.count > 5\n        # Indicates that the data stream is closed.\n        # This is the last time that the function will be called\n        return nothing\n    end\n\n    return c.count\nend\n\nstruct AddConstantCalculator\n    constant::Int\nend\n\nfunction Tissue.process(c::AddConstantCalculator, num_in::Int)::Int\n    return num_in + c.constant\nend\n\nstruct MultiplyCalculator end\n\nfunction Tissue.process(c::MultiplyCalculator, first_num::Int, second_num::Int)::Int\n    return first_num * second_num\nend\n\nstruct PrinterCalculator end\n\nfunction Tissue.process(c::PrinterCalculator, num_to_print)\n    println(num_to_print)\nend\n\n@graph NumberGraph begin\n    # 1. Declare calculators.\n    @calculator source  = SourceCalculator()\n    @calculator add0    = AddConstantCalculator(0)\n    @calculator add42   = AddConstantCalculator(42)\n    @calculator mult    = MultiplyCalculator()\n    @calculator printer = PrinterCalculator()\n\n    # 2. Declare the streams which connect the calculators together\n    @bindstreams add0 (num_in = source)\n    @bindstreams add42 (num_in = source)\n    @bindstreams mult (first_num = add0) (second_num = add42)\n    @bindstreams printer (num_to_print = mult)\nend\n\ngraph = NumberGraph()\nstart(graph)\nwait_until_done(graph)\n\n# output\n43\n88\n135\n184\n235","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Feel free to run the code yourself. Remember that in Julia, you control the number of threads that get spawned when you run the program. See the --threads command line option. To run the program with as many threads as your computer has CPUs, use","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"$ julia -t auto my_program.jl","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Alright, back to the example. There's a lot going on here, so let's parse through this example one bit at a time.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Tissue","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This brings the functions and macros we are going to need into scope: ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"start() launches all the calculators, each in its own task, and starts pulling data from the source calculator\nwait_until_done() blocks the main thread until the source stops generating data, and all calculators are done processing.\n@graph defines a graph, concretely a struct NumberGraph, with a topology as described in the begin ... end block.\n@calculator declares a new node in the graph corresponding to a calculator object of any type.\n@bindstreams declares the edges in the graph. To define an edge, one specifies the output of a calculator with a named input stream of another calculator.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"mutable struct SourceCalculator \n    count::Int64\n    SourceCalculator() = new(0)\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This defines a calculator type which we will use to instantiate our source calculator. The source calculator is the one and only node in the graph which has no input streams. It is equally an error to instantiate more than one, or none at all. As you can see, there's nothing special about the type. More on the source calculator when we get to the graph definition.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"function Tissue.process(c::SourceCalculator)\n    c.count += 1\n    if c.count > 5\n        # Indicates that the data stream is closed.\n        # This is the last time that the function will be called\n        return nothing\n    end\n\n    return c.count\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is the crux of it all. We specify how a calculator of type X goes from input to output by adding a method to the Tissue.process() function; that is, the process() function that lives in the Tissue module. The convention is that the first argument to the function needs to be of type X, and the rest of the arguments define the streams which the calculator accepts. In this case, there are no streams, because we intend to use this calculator as our source calculator.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Note that more than one Tissue.process(c::X, ...) can be implemented. This is how you let the same calculator accept different streams, depending on the graph it is to be used in.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"struct AddConstantCalculator\n    constant::Int\nend\n\nfunction Tissue.process(c::AddConstantCalculator, num_in::Int)::Int\n    return num_in + c.constant\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We define a new calculator type called AddConstantCalculator. There is one difference with the source calculator though: its process() method accepts one stream named num_in. This is key. The name of the arguments in a process() method matter. They name a stream that will later be used when defining the graph topology with the @graph and @bindstreams macros. More on this later.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Here, we specified the type of the stream and the return type of process() for documentation purposes; they are by no means required.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"struct MultiplyCalculator end\n\nfunction Tissue.process(c::MultiplyCalculator, first_num::Int, second_num::Int)::Int\n    return first_num * second_num\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We define a new calculator type called MultiplyCalculator, as well as a process() which now takes 2 stream arguments. This is interesting. Remember that all calculators in the graph run concurrently. Then, both values are going to arrive at this calculator at different points in time. As a result, Tissue.jl buffers the data until at least one packet per stream has arrived, after which it calls this process() method. This complexity taken care for you is one of the perks of Tissue.jl.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"struct PrinterCalculator end\n\nfunction Tissue.process(c::PrinterCalculator, num_to_print)\n    println(num_to_print)\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Come to our final calculator type, PrinterCalculator. Nothing new here, except to show that really, all computation, including I/O calls, happens within calculators.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@graph NumberGraph begin","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Finally, we get to the graph definition. The @graph macro takes 2 arguments: The name of the type, NumberGraph, and a code block in which we use @calculator and @bindstreams to define the topology; that is, the nodes and edges of the graph.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"    # 1. Declare calculators.\n    @calculator source  = SourceCalculator()","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This defines a new calculator object of type SourceCalculator, and source is the variable that refers to it. This looks like and is a simple variable assignment as you know it, using the SourceCalculator struct constructor that you defined. The default one in this case.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"    @calculator add0    = AddConstantCalculator(0)\n    @calculator add42   = AddConstantCalculator(42)\n    @calculator mult    = MultiplyCalculator()\n    @calculator printer = PrinterCalculator()","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Similarly, this defines four new calculator objects. Note that add0 and add42 are two calculators of the same type.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"    # 2. Declare the streams which connect the calculators together\n    @bindstreams add0 (num_in = source)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We get to our first @bindstreams declaration. The purpose of @bindstreams is to encode, for each calculator in our graph, where the data comes from for each stream. Here, the add0's input stream called num_in will have its data come from the output stream of source. The parentheses around num_in = source are optional; we add them for clarity. Visually, this adds an edge in the graph from source to add0. As a reminder, we declared the stream num_in when we defined the process(c::AddConstantCalculator, num_in::Int) method.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"    @bindstreams add42 (num_in = source)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This declaration is analogous to the previous one.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"    @bindstreams mult (first_num = add0) (second_num = add42)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The process() method that we defined for the MultiplyCalculator defines two streams: first_num and second_num. Therefore, the @bindstreams declaration must bind the output of a calculator to each of them. By now, you probably figured out what this does: it takes the output of add0 and sends it in mult's first_num stream, and similarly for add42 in the second_num stream.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"    @bindstreams printer (num_to_print = mult)\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is the final @bindstreams declaration, which completes the graph definition! We defined all of our calculators and how they interact. Note that we didn't bind any stream to source, which tells Tissue.jl that this is the calculator we intend to use as our source calculator.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"graph = NumberGraph()","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We now get to actually use our graph! The @graph macro created a struct NumberGraph with a default constructor. We thus instantiate a new graph simply by creating an object of type NumberGraph.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"start(graph)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This call starts every calculator in its own task and starts pulling data from the source calculator. It returns immediately.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"wait_until_done(graph)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Finally, this blocks the main thread until the graph is done. In our case, this happens when our source returns nothing, indicating that it is done generating data. wait_until_done will wait until all the calculators are finished processing the last packet, cleanup and return.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"That's all folks! Now, there's a thing or two we omitted in this example, so if you're hungry for more, follow me on to a more complicated example.","category":"page"},{"location":"getting_started/#A-more-useful-example","page":"Getting Started","title":"A more useful example","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's look at a more realistic example. We will write a graph which reads from the camera, runs a face detector on the image, and renders a box around the detected faces. At any time, the user can select the video feed window on their desktop and press any key to stop the graph. We will convert this example from OpenCV into a Tissue.jl graph.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Tissue\nusing OpenCV\ncv = OpenCV\n\nstruct CameraCalculator\n    cap::cv.VideoCaptureAllocated\n\n    function CameraCalculator()\n        cap = cv.VideoCapture(Int32(0))\n        new(cap)\n    end\nend\n\nfunction Tissue.process(calc::CameraCalculator)\n    ok, img = cv.read(calc.cap)\n    ok ? img : nothing\nend\n\nfunction Tissue.close(calc::CameraCalculator)\n    cv.release(calc.cap)\nend\n\nstruct FaceDetectionCalculator\n    net\n\n    function FaceDetectionCalculator()\n        net = cv.dnn_DetectionModel(\n            \"assets/opencv_face_detector.pbtxt\",\n            \"assets/opencv_face_detector_uint8.pb\",\n        )\n        size0 = Int32(300)\n        cv.dnn.setInputMean(net, (104, 177, 123))\n        cv.dnn.setInputScale(net, 1.0)\n        cv.dnn.setInputSize(net, size0, size0)\n\n        new(net)\n    end\nend\n\nfunction Tissue.process(calc::FaceDetectionCalculator, in_frame)\n    classIds, confidences, boxes =\n        cv.dnn.detect(calc.net, in_frame, confThreshold = Float32(0.5))\n\n    (confidences, boxes)\nend\n\nstruct FaceRendererCalculator end\n\nfunction Tissue.process(calc::FaceRendererCalculator, in_frame, confidences_and_boxes)\n    confidences, boxes = confidences_and_boxes\n\n    out_frame = deepcopy(in_frame)\n\n    for i in 1:size(boxes,1)\n        confidence = confidences[i]\n        x0 = Int32(boxes[i].x)\n        y0 = Int32(boxes[i].y)\n        x1 = Int32(boxes[i].x+boxes[i].width)\n        y1 = Int32(boxes[i].y+boxes[i].height)\n        cv.rectangle(out_frame, cv.Point{Int32}(x0, y0), cv.Point{Int32}(x1, y1), (100, 255, 100); thickness = Int32(5))\n        label = \"face: \" * string(confidence)\n        lsize, bl = cv.getTextSize(label, cv.FONT_HERSHEY_SIMPLEX, 0.5, Int32(1))\n        cv.rectangle(out_frame, cv.Point{Int32}(x0,y0), cv.Point{Int32}(x0+lsize.width, y0+lsize.height+bl), (100,255,100); thickness = Int32(-1))\n        cv.putText(out_frame, label, cv.Point{Int32}(x0, y0 + lsize.height),\n        cv.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0); thickness = Int32(1), lineType = cv.LINE_AA)\n    end\n\n    out_frame\nend\n\nstruct ImageDisplayCalculator end\n\nfunction Tissue.process(calc::ImageDisplayCalculator, rendered_frame; graph::Graph)\n    cv.imshow(\"detections\", rendered_frame)\n\n    if cv.waitKey(Int32(1)) >= 0\n        stop(graph)\n    end\nend\n\n@graph FaceGraph begin\n    @calculator source = CameraCalculator()\n    @calculator face_detector = FaceDetectionCalculator()\n    @calculator renderer = FaceRendererCalculator()\n    @calculator displayer = ImageDisplayCalculator()\n\n    @bindstreams face_detector (in_frame = source)\n    @bindstreams renderer (in_frame = source) (confidences_and_boxes = face_detector)\n    @bindstreams displayer (rendered_frame = renderer)\nend\n\nfunction main()\n    graph = FaceGraph()\n    start(graph)\n    wait_until_done(graph)\n    println(\"Thanks for listening!\")\nend\n\nmain()","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You can actually run this yourself! Just make sure you install the OpenCV package first (simply type add OpenCV on julia's pkg REPL).","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We will focus on the bits that were not covered in the previous example.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"function Tissue.close(calc::CameraCalculator)\n    cv.release(calc.cap)\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To clean up resources acquired in a calculator constructor when the graph stops, implement Tissue.close(::CalculatorType) with the corresponding calculator type. It will be called in wait_until_done(graph) after all the calculators are done running.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"function Tissue.process(calc::FaceRendererCalculator, in_frame, confidences_and_boxes)\n    confidences, boxes = confidences_and_boxes\n\n    out_frame = deepcopy(in_frame)\n\n    for i in 1:size(boxes,1)\n        ...\n    end\n\n    out_frame\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The process() method for the FaceRendererCalculator highlights an important fact: data coming from the input streams could be accessed by multiple threads simultaneously since calculators run in their own task. Therefore, we treat the data coming from input streams as immutable. Since we want to mutate it here, we first make a deepcopy.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"function Tissue.process(calc::ImageDisplayCalculator, rendered_frame; graph::Graph)\n    cv.imshow(\"detections\", rendered_frame)\n\n    if cv.waitKey(Int32(1)) >= 0\n        stop(graph)\n    end\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Finally, the process() method for ImageDisplayCalculator introduces two new concepts. First, a reference to the current graph object can be obtained by adding a graph keyword argument to the process() method. In this case, we need it to call Tissue.stop(graph), the second new concept. Tissue.stop(graph) does as the name suggests: it stops the graph. This means a few things: the source calculator stops being called for new data packets, all packets that were generated are allowed to be processed by all calculators. After no more packets remain in the graph, if the main thread is blocked on a call to Tissue.wait_until_done(graph), Tissue.close(calculator) is called on every calculator. Although there is no race condition here: if the main thread calls Tissue.wait_until_done(graph) only after all calculators are done, Tissue.close(calculator) is also called on all calculators.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"And that's pretty much it! You should be good to go build awesome graphs now.","category":"page"},{"location":"design_decisions/#Design-decisions","page":"Design decisions","title":"Design decisions","text":"","category":"section"},{"location":"design_decisions/","page":"Design decisions","title":"Design decisions","text":"TODO: document why things are designed that way","category":"page"},{"location":"design_decisions/","page":"Design decisions","title":"Design decisions","text":"one and only one source calculator\none output stream per calculator\n...","category":"page"},{"location":"#Tissue.jl","page":"Introduction","title":"Tissue.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The core idea behind Tissue.jl is to simplify the processing of data streams while maximizing performance with parallelization. The processing pipeline is modeled as a directed acyclic graph, where each node runs in its own task. Nodes, which we call calculators, send each other packets over streams, the directed edges of the graph. If each node is a biological cell, then a graph would be a tissue, wouldn't it?","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Download and install Julia 1.x if you haven't already. To install Tissue.jl, launch julia and type the following.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> ]\n(@v1.x) pkg> add Tissue","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia's package manager will install Tissue.jl in the active environment.","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Here's what programming in Tissue.jl looks like.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Write your calculators\nThis is where all the computation happens. One and only one of these calculators, identified by the fact that it takes no input, is the source.\nDefine the graph topology\nUsing our graph definition Domain Specific Language (DSL), define how the data flows from one calculator to the next.\nRun the graph\nStart the graph and let it do its thing. Tissue.jl will run all the calculators concurrently and pull data from the source calculator as fast as your graph can handle it.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"When you write a calculator, you can specify the different set of streams it can accept, with a behavior corresponding to each set. Hence, calculators are reusable across different graph topologies. It's also easy to define new sets of streams a calculator can accept, lending on the power of multiple dispatch. It's therefore easy to adapt other people's calculators to fit nicely in your graph. Working in Tissue.jl also lends itself to working in teams. Different people work on different calculators, and you stitch the calculators together in one or more graphs at the end.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A core feature of Tissue.jl is the flow limiter. Every graph has one and only one source, which generates the next datum in the data stream to be processed. The flow limiter is the component that determines the rate at which data should be pulled out of the source so as to pull data out of the source as fast as the graph can process it. The flow limiter keeps internal statistics about how long it takes for each calculator to process the data packets. Thus, for example, if your CPUs get too hot and throttled, the flow limiter will detect that change and adjust the rate at which data is pulled out of the source so as not to overflow the graph with packets.","category":"page"},{"location":"main_concepts/#Main-concepts","page":"Main concepts","title":"Main concepts","text":"","category":"section"},{"location":"main_concepts/","page":"Main concepts","title":"Main concepts","text":"Here, give an extended discussion on the main concepts\nFlow limiter\nBootstrap process\nprocess() resolving\nsource and sink streams\ngraph definition DSL\nImmutability of packets","category":"page"},{"location":"main_concepts/","page":"Main concepts","title":"Main concepts","text":"Calculator: a stateful node in the graph which processes inputs to form outputs\nSource: a special calculator which generates the data stream (e.g. video stream) that will be processed by the graph.\nStream: the edges in the graph. \nOutput stream: ","category":"page"}]
}
